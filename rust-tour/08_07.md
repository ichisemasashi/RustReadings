## スマートな安全でないコード

スマートポインターは、かなり頻繁に*安全でない*コードを使用する傾向があります。先に述べたように、Rustでは最下層のメモリを操作するための一般的なツールです。

安全でないコードとは何ですか？安全でないコードは、Rustコンパイラが保証できないいくつかの能力を除いて、通常のRustとまったく同じように動作します。

安全でないコードの主な機能は、生のポインタを再参照することです。つまり、メモリ上のある位置への *生のポインタ* を取って、「ここにデータ構造があります！」と宣言して、それを使えるデータの表現に変えることです（例えば、`*const u8` を `u8` に）。Rust には、メモリに書き込まれるすべてのバイトの意味を追跡する方法はありません。Rust は *生のポインタ* として使用される任意の数値に何が存在するかを保証することができないので、 `unsafe { ...' の中に参照解除を置きます。}` ブロックに入れます。

スマートポインターは*生のポインタを広範囲に参照*しますが、その動作は十分に証明されています。

```
fn main() {
    let a: [u8; 4] = [86, 14, 73, 64];
    // これは生ポインタです。何かのメモリアドレス
    // を数値で取得するのは全く安全です
    let pointer_a = &a as *const u8 as usize;
    println!("Data memory location: {}", pointer_a);
    // この数値をf32への生ポインタに変換することも安全です。
    let pointer_b = pointer_a as *const f32;
    let b = unsafe {
        // これは、ポインタが有効なf32であると仮定して、
        // その値を変数bにデリファレンスするようにコンパイラ
        // に指示しているため、安全ではありません。
        *pointer_b
    };
    println!("I swear this is a pie! {}", b);
}
```