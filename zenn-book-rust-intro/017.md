# ライフタイム {#ライフタイム .View_chapterTitle__tslMs}

## [](#%F0%9F%93%8C-%E3%83%A9%E3%82%A4%E3%83%95%E3%82%BF%E3%82%A4%E3%83%A0){.header-anchor-link} 📌 ライフタイム {#%F0%9F%93%8C-%E3%83%A9%E3%82%A4%E3%83%95%E3%82%BF%E3%82%A4%E3%83%A0}

**ライフタイム**
というのは参照が有効になるスコープのことです．参照は原本の所有権が存在している限り有効なもので，借用チェックによって厳密にチェックされます．元々，関数に渡すために参照で仮の所有権を渡して破棄してもらう仕組みなのに，それを関数の返り値として返すとはおかしな話です．Rust
はパフォーマンスを最優先しているので，仕方ないとは思います．返せたほうが便利なときもあるでしょう．Rust
の初期版では参照を使っているところは明示的にすべてライフタイムを指定する必要があったようですが，今はかなり緩和されました．

ライフタイムは `&` 演算子の後ろに指定します．慣例的に `a,b,c,…`
と指定します．

::: code-block-container
``` language-rust
&i32        // a reference
&'a i32     // a reference with an explicit lifetime
&'a mut i32 // a mutable reference with an explicit lifetime
```
:::

特別なライフタイムの１つに `‘static`
があります．これはプログラム実行中にずっと存在するライフタイムです．ライフタイムが
`‘static`
なオブジェクトはデータメモリに置かれます．例えば，文字列リテラルは
`‘static` なライフタイムを持っています．

ライフタイムを指定したコードは本当に見づらいので，なるべくライフタイムを指定するようなコードは書かないほうがいいとは思います．

::: code-block-container
``` language-rust
impl<'i, 't, 'a, R, P, E: 'i> RuleListParser<'i, 't, 'a, P>
where
    P: QualifiedRuleParser<'i, QualifiedRule = R, Error = E>
        + AtRuleParser<'i, AtRule = R, Error = E>,
{
    pub fn new_for_stylesheet(input: &'a mut Parser<'i, 't>, parser: P) -> Self {
        // ...
    }
}
```
:::
:::
:::
:::

