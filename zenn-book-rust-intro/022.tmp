# ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ {#ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ .View_chapterTitle__tslMs}

## ğŸ“Œ ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã¨ã¯

Rust
ã®æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã«ã¯ä¾¿åˆ©ãªè¤‡æ•°ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç®¡ç†ã™ã‚‹ãƒ‡ãƒ¼ã‚¿æ§‹é€ ãŒç”¨æ„ã•ã‚Œã¦ã„ã¾ã™ï¼ã“ã‚Œã‚‰ã‚’
**ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³**
ã¨å‘¼ã³ã¾ã™ï¼ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã¯ãƒ’ãƒ¼ãƒ—ãƒ¡ãƒ¢ãƒªã«ç½®ã‹ã‚Œã¾ã™ï¼ã“ã“ã§ã¯ä»£è¡¨çš„ãªã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’è§£èª¬ã—ã¾ã™ï¼

## ğŸ“Œ Vec

ãƒ™ã‚¯ã‚¿ `Vec<T>` ã¯ä¼¸ç¸®å¯èƒ½ãªé…åˆ—ã§ã™ï¼ç©ºã®ãƒ™ã‚¯ã‚¿ã‚’ä½œæˆã™ã‚‹ã«ã¯
`Vec::new` ã‚’ä½¿ã„ã¾ã™ï¼š


``` 
let v: Vec<i32> = Vec::new();
```


åˆæœŸå€¤ã‚’æŒ‡å®šã—ã¦ãƒ™ã‚¯ã‚¿ã‚’ä½œæˆã™ã‚‹å ´åˆã¯ `vec!` ãƒã‚¯ãƒ­ã‚’ä½¿ã„ã¾ã™ï¼š


``` 
let v = vec![1, 2, 3];
```


å„è¦ç´ ã‚’å–ã‚Šå‡ºã—ã¦å‡¦ç†ã™ã‚‹ä¸€èˆ¬çš„ãªæ–¹æ³•ã¯ `for` å¼ã‚’ä½¿ã„ã¾ã™ï¼š


``` 
let v = vec![100, 32, 57];
for i in &v {
    println!("{}", i);
}
```


`Vec<T>` ã®ãƒ¡ã‚½ãƒƒãƒ‰ã®ä¸€éƒ¨ã§ã™ï¼š


``` 
insert(&mut self, index: usize, element: T)
remove(&mut self, index: usize) -> T
push(&mut self, value: T)
pop(&mut self) -> Option<T>
append(&mut self, other: &mut Vec<T>)
clear(&mut self)
len(&self) -> usize
is_empty(&self) -> bool
first(&self) -> Option<&T>
first_mut(&mut self) -> Option<&mut T>
last(&self) -> Option<&T>
last_mut(&mut self) -> Option<&mut T>
```


## ğŸ“Œ String

**æ–‡å­—åˆ—** ã‚’è¡¨ã™ `String` ã‚‚ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã§ã™ï¼å†…éƒ¨ã§ã¯ **UTF-8**
ã§ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã§ã™ï¼æ–‡å­—åˆ—å‹ã«ã¯ `OsString`, `OsStr`,
`CString`, `CStr`, `String`, `str`
ãªã©ãŒã‚ã‚Šã¾ã™ï¼ãã‚Œãã‚Œï¼Œã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰æ–¹å¼ãŒé•ã„ã¾ã™ï¼ `String` ã¨ `str`
ã®ã‚ˆã†ã«ãƒšã‚¢ã«ãªã£ã¦ãŠã‚Šï¼Œ `str` ã¯ã‚¹ãƒ©ã‚¤ã‚¹ã§ã™ï¼

æ–‡å­—åˆ—ã®ç”Ÿæˆã¯ `String::new` ã§ã™ï¼š


``` 
let mut s = String::new();
```


æ–‡å­—åˆ—ä»¥å¤–ã®å‹ã‹ã‚‰ï¼Œæ–‡å­—åˆ—ã«å¤‰æ›ã™ã‚‹ã«ã¯ `to_string`
ãƒ¡ã‚½ãƒƒãƒ‰ãŒä¾¿åˆ©ã§ã™ï¼ã“ã‚Œã¯ `Display`
ãƒˆãƒ¬ã‚¤ãƒˆã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãªã‚‰è‡ªå‹•ã§å®Ÿè£…ã—ã¦ãã‚Œã¾ã™ï¼


``` 
let i = 5;
let five = i.to_string();
```


æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã‹ã‚‰ã®ä½œæˆã¯ `String::from` ã‚’ä½¿ã„ã¾ã™ï¼š


``` 
let five = String::from("5");
```


æ–‡å­—åˆ—ã‹ã‚‰æ•°å€¤å‹ã«å¤‰æ›ã™ã‚‹ã«ã¯ `parse` ã‚’ä½¿ã„ã¾ã™ï¼ã“ã‚Œã¯ `Result`
å‹ã‚’è¿”ã—ã¾ã™ï¼š


``` 
let a_string = String::from("5");
let b = a_string.parse::<i32>()?;
```


æ›¸å¼ä»˜ãã§æ–‡å­—åˆ—ã‚’ä½œæˆã™ã‚‹ã«ã¯ `format!` ãƒã‚¯ãƒ­ã‚’ä½¿ã„ã¾ã™ï¼š


``` 
let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");
let s = format!("{}-{}-{}", s1, s2, s3);
```


`String` ã®ãƒ¡ã‚½ãƒƒãƒ‰ã®ä¸€éƒ¨ã§ã™ï¼š


``` 
push_str(&mut self, string: &str)
push(&mut self, ch: char)
pop(&mut self) -> Option<char>
as_bytes(&self) -> &[u8]
truncate(&mut self, new_len: usize)
insert(&mut self, idx: usize, ch: char)
insert_str(&mut self, idx: usize, string: &str)
remove(&mut self, idx: usize) -> char
len(&self) -> usize
is_empty(&self) -> bool
clar(&mut self)
chars(&self) -> Chars<'_>
bytes(&self) -> Bytes<'_>
starts_with<'a,P>(&'a self, pat: P) -> bool
ends_with<'a,P>(&'a self, pat: P) -> bool
find<'a, P>(&'a self, pat: P) -> Option<usize>
rfind<'a, P>(&'a self, pat: P) -> Option<usize>
trim(&self) -> &str
```


## ğŸ“Œ HashMap

`HashMap<K,V>` ã¯ **é€£æƒ³é…åˆ—**
ã§ã™ï¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã‚­ãƒ¼ã‚’çµã³ã¤ã‘ã¦ç®¡ç†ã—ã¾ã™ï¼ç©ºã®é€£æƒ³é…åˆ—ã‚’ä½œæˆã™ã‚‹ã«ã¯
`HashMap::new` ã‚’ä½¿ã„ï¼Œæ–°ã—ã„è¦ç´ ã‚’æŒ¿å…¥ã™ã‚‹å ´åˆã¯ `insert` ã‚’ä½¿ã„ã¾ã™ï¼š


``` 
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);
```


ã‚­ãƒ¼ã«å¯¾å¿œã—ãŸè¦ç´ ã‚’å–å¾—ã™ã‚‹ã«ã¯ \`get ã‚’ä½¿ã„ã¾ã™ï¼š


``` 
use std::collections::HashMap;

let mut scores = HashMap::new();
scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);

let team_name = String::from("Blue");
let score = scores.get(&team_name);
```


å„è¦ç´ ã‚’å–ã‚Šå‡ºã™å ´åˆã¯ `for` å¼ã§ï¼Œã‚­ãƒ¼ã¨ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’åˆ†è§£æŸç¸›ã—ã¾ã™ï¼š


``` 
use std::collections::HashMap;

let mut scores = HashMap::new();
scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);

for (key, value) in &scores {
    println!("{}: {}", key, value);
}
```


ã‚­ãƒ¼ãŒã¾ã å­˜åœ¨ã—ã¦ã„ãªã„ã¨ãã«æŒ¿å…¥ã™ã‚‹å ´åˆã¯ `entry` ã¨ `or_insert`
ã‚’ä½¿ã„ã¾ã™ï¼š


``` 
use std::collections::HashMap;

let mut scores = HashMap::new();
scores.insert(String::from("Blue"), 10);
scores.entry(String::from("Yellow")).or_insert(50);
scores.entry(String::from("Blue")).or_insert(50);
println!("{:?}", scores);
```


ï¼’ã¤ã®ãƒ™ã‚¯ã‚¿ã‹ã‚‰é€£æƒ³é…åˆ—ã‚’ä½œæˆã™ã‚‹ã«ã¯ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’ä½¿ã£ã¦ï¼Œ `zip`,
`collect` ã‚’ä½¿ã†æ–¹æ³•ãŒã‚ã‚Šã¾ã™ï¼š


``` 
use std::collections::HashMap;

let teams = vec![String::from("Blue"), String::from("Yellow")];
let initial_scores = vec![10, 50];

let mut scores: HashMap<_, _> =
    teams.into_iter().zip(initial_scores.into_iter()).collect();
```


`HashMap<K,V>` ã®ãƒ¡ã‚½ãƒƒãƒ‰ã®ä¸€éƒ¨ã§ã™ï¼š


``` 
keys(&self) -> Keys<'_, K, V>
values(&self) -> Values<'_, K, V>
values_mut(&mut self) -> ValuesMut<'_, K, V>
iter(&self) -> Iter<'_, K, V>
iter_mut(&mut self) -> IterMut<'_, K, V>
len(&self) -> usize
clear(&mut self)
entry(&mut self, key: K) -> Entry<'_, K, V>
contains_key<Q: ?Sized>(&self, k: &Q) -> bool
insert(&mut self, k: K, v: V) -> Option<V>
remove<Q: ?Sized>(&mut self, k: &Q) -> Option<V>
```





