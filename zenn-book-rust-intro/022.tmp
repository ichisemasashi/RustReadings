# コレクション {#コレクション .View_chapterTitle__tslMs}

## 📌 コレクションとは

Rust
の標準ライブラリには便利な複数のオブジェクトを管理するデータ構造が用意されています．これらを
**コレクション**
と呼びます．コレクションはヒープメモリに置かれます．ここでは代表的なコレクションを解説します．

## 📌 Vec

ベクタ `Vec<T>` は伸縮可能な配列です．空のベクタを作成するには
`Vec::new` を使います：


``` 
let v: Vec<i32> = Vec::new();
```


初期値を指定してベクタを作成する場合は `vec!` マクロを使います：


``` 
let v = vec![1, 2, 3];
```


各要素を取り出して処理する一般的な方法は `for` 式を使います：


``` 
let v = vec![100, 32, 57];
for i in &v {
    println!("{}", i);
}
```


`Vec<T>` のメソッドの一部です：


``` 
insert(&mut self, index: usize, element: T)
remove(&mut self, index: usize) -> T
push(&mut self, value: T)
pop(&mut self) -> Option<T>
append(&mut self, other: &mut Vec<T>)
clear(&mut self)
len(&self) -> usize
is_empty(&self) -> bool
first(&self) -> Option<&T>
first_mut(&mut self) -> Option<&mut T>
last(&self) -> Option<&T>
last_mut(&mut self) -> Option<&mut T>
```


## 📌 String

**文字列** を表す `String` もコレクションです．内部では **UTF-8**
でエンコードされたデータです．文字列型には `OsString`, `OsStr`,
`CString`, `CStr`, `String`, `str`
などがあります．それぞれ，エンコード方式が違います． `String` と `str`
のようにペアになっており， `str` はスライスです．

文字列の生成は `String::new` です：


``` 
let mut s = String::new();
```


文字列以外の型から，文字列に変換するには `to_string`
メソッドが便利です．これは `Display`
トレイトのインスタンスなら自動で実装してくれます．


``` 
let i = 5;
let five = i.to_string();
```


文字列リテラルからの作成は `String::from` を使います：


``` 
let five = String::from("5");
```


文字列から数値型に変換するには `parse` を使います．これは `Result`
型を返します：


``` 
let a_string = String::from("5");
let b = a_string.parse::<i32>()?;
```


書式付きで文字列を作成するには `format!` マクロを使います：


``` 
let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");
let s = format!("{}-{}-{}", s1, s2, s3);
```


`String` のメソッドの一部です：


``` 
push_str(&mut self, string: &str)
push(&mut self, ch: char)
pop(&mut self) -> Option<char>
as_bytes(&self) -> &[u8]
truncate(&mut self, new_len: usize)
insert(&mut self, idx: usize, ch: char)
insert_str(&mut self, idx: usize, string: &str)
remove(&mut self, idx: usize) -> char
len(&self) -> usize
is_empty(&self) -> bool
clar(&mut self)
chars(&self) -> Chars<'_>
bytes(&self) -> Bytes<'_>
starts_with<'a,P>(&'a self, pat: P) -> bool
ends_with<'a,P>(&'a self, pat: P) -> bool
find<'a, P>(&'a self, pat: P) -> Option<usize>
rfind<'a, P>(&'a self, pat: P) -> Option<usize>
trim(&self) -> &str
```


## 📌 HashMap

`HashMap<K,V>` は **連想配列**
です．オブジェクトにキーを結びつけて管理します．空の連想配列を作成するには
`HashMap::new` を使い，新しい要素を挿入する場合は `insert` を使います：


``` 
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);
```


キーに対応した要素を取得するには \`get を使います：


``` 
use std::collections::HashMap;

let mut scores = HashMap::new();
scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);

let team_name = String::from("Blue");
let score = scores.get(&team_name);
```


各要素を取り出す場合は `for` 式で，キーとオブジェクトを分解束縛します：


``` 
use std::collections::HashMap;

let mut scores = HashMap::new();
scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);

for (key, value) in &scores {
    println!("{}: {}", key, value);
}
```


キーがまだ存在していないときに挿入する場合は `entry` と `or_insert`
を使います：


``` 
use std::collections::HashMap;

let mut scores = HashMap::new();
scores.insert(String::from("Blue"), 10);
scores.entry(String::from("Yellow")).or_insert(50);
scores.entry(String::from("Blue")).or_insert(50);
println!("{:?}", scores);
```


２つのベクタから連想配列を作成するにはイテレータを使って， `zip`,
`collect` を使う方法があります：


``` 
use std::collections::HashMap;

let teams = vec![String::from("Blue"), String::from("Yellow")];
let initial_scores = vec![10, 50];

let mut scores: HashMap<_, _> =
    teams.into_iter().zip(initial_scores.into_iter()).collect();
```


`HashMap<K,V>` のメソッドの一部です：


``` 
keys(&self) -> Keys<'_, K, V>
values(&self) -> Values<'_, K, V>
values_mut(&mut self) -> ValuesMut<'_, K, V>
iter(&self) -> Iter<'_, K, V>
iter_mut(&mut self) -> IterMut<'_, K, V>
len(&self) -> usize
clear(&mut self)
entry(&mut self, key: K) -> Entry<'_, K, V>
contains_key<Q: ?Sized>(&self, k: &Q) -> bool
insert(&mut self, k: K, v: V) -> Option<V>
remove<Q: ?Sized>(&mut self, k: &Q) -> Option<V>
```





