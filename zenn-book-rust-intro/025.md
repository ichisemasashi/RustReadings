# ユニットテスト {#ユニットテスト .View_chapterTitle__tslMs}

## [](#%F0%9F%93%8C-%E3%83%A6%E3%83%8B%E3%83%83%E3%83%88%E3%83%86%E3%82%B9%E3%83%88){.header-anchor-link} 📌 ユニットテスト {#%F0%9F%93%8C-%E3%83%A6%E3%83%8B%E3%83%83%E3%83%88%E3%83%86%E3%82%B9%E3%83%88}

Rust
にはテストコードを記述する機能が用意されています．テストを実行するには以下のコマンドを実行します：

::: code-block-container
    cargo test
:::

実行するユニットテストの関数には `test` 属性を付けます：

::: code-block-container
``` language-rust
#[test]
fn it_works() {
    assert_eq!(2 + 2, 4);
}
```
:::

テスト時のみ（`cargo test`）ビルドするモジュールを作ることが出来ます．それにはモジュールの前に
`cfg(test)` 属性を付けます．

::: code-block-container
``` language-rust
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
```
:::

テストに便利なマクロがいくつか用意されています． `assert!`
マクロは引数が `true` かどうかをテストします．また， `==` や `!=`
演算子を使う代わりに `assert_eq!`， `assert_ne!`
マクロが用意されています．

::: code-block-container
``` language-rust
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert!(2 == 2);
        assert_eq!(2 + 2, 4);
        assert_ne!(2 + 2, 5);
    }
}
```
:::

`assert!` マクロや， `unwrap` などは `panic!`
を呼び出す場合があります．場合によっては `panic!`
が呼び出されることを期待したテストコードを記述したい場合があります．しかし，テストは通常
`panic!` を起こすと失敗になります．そこで， `should_panic`
属性を付けることで， `panic!`
を起こすことがテストの目的であることを明示します：

::: code-block-container
``` language-rust
#[test]
#[should_panic]
fn it_works() {
    panic!();
}
```
:::
:::
:::
:::

